package ch.jodersky.sbt.jni

import build._
import ch.jodersky.jni.{NativeLoader, Platform}
import sbt._
import sbt.Keys._

object JniPackager extends AutoPlugin {

  override def requires = Jni
  override def trigger = allRequirements

  object autoImport {

    //Main task, inspect this first
    //val packageNative = taskKey[File]("Packages native libraries in a jar.")

    //val packageNativeMappings = taskKey[Seq[(File, String)]]("")

    val nativeLibraryPath = settingKey[String](
      "String that is prepended to the path of a native library when packaged.")

    val enableNativeCompilation = settingKey[Boolean](
      "Determines if native compilation is enabled in a scoped key (typically for packaging).")

    val unmanagedNativeDirectories = settingKey[Seq[File]](
      """|Unmanaged directories containing native libraries. The libraries must be regular files
         |contained in a subdirectory corresponding to a platform.""".stripMargin)

    val unmanagedNativeLibraries = taskKey[Map[Platform, File]]("")

    val managedNativeLibraries = taskKey[Map[Platform, File]]("")

  }
  import autoImport._
  import Jni.autoImport._

  lazy val settings: Seq[Setting[_]] = Seq(

    nativeLibraryPath := {
      val orgPath = organization.value.replaceAll("\\.", "/")
      s"/${orgPath}/${name.value}/native"
    },

    //Make NativeLoader available to project
    libraryDependencies += "ch.jodersky" %% "jni-library" % Version.PluginVersion,

    name in packageNative := {
      name.value + "-native-" + version.value + ".jar"
    },

    enableNativeCompilation := true,

    unmanagedNativeDirectories := Seq(baseDirectory.value / "lib_native"),

    unmanagedNativeLibraries := {
      val dirs: Seq[File] = unmanagedNativeDirectories.value
      val seq: Seq[(Platform, File)] = for (
        dir <- dirs;
        platformDir <- dir.listFiles();
        if platformDir.isDirectory;
        platform = Platform.fromId(platformDir.name);
        library <- platformDir.listFiles();
        if library.isFile
      ) yield {
        platform -> library.getCanonicalFile()
      }

      seq.toMap
    },

    managedNativeLibraries := Def.taskDyn[Map[Platform, File]]{
      val enableManaged = (enableNativeCompilation).value
      if (enableManaged) Def.task {
        val library: File = (nativeCompile in Compile).value
        val platform = (nativePlatform in Compile).value
        Map(platform -> library)
      } else Def.task{
        Map()
      }
    }.value,

    resourceGenerators in Compile += Def.task {

      val libraries: Seq[(Patform, File)] = (managedNativeLibraries.value ++ unmanagedNativeLibraries.value).toSeq

      val resources: Seq[File] = for ((plat, file) <- libraries) yield {

        //native library as a managed resource file
        val resource = (resourceManaged in Compile).value /
          NativeLoader.fullLibraryPath(
            (nativeLibraryPath).value,
            plat)

        //copy native library to a managed resource (so it can also be loaded when not packaged as a jar)
        IO.copyFile(file, resource)
        resource
      }
      resources
    }.taskValue,

    //don't add scala version to native jars
    crossPaths := false

  )

  override lazy val projectSettings = settings
    /*
     name in packageNative := name,


     //this is file name of the artifact
     artifactName in packageNative := { (sv: ScalaVersion, module: ModuleID, artifact: Artifact) =>
     artifact.name + "-native." + module.revision + "." + artifact.extension
     }

     packageNative := {
     val log = streams.value.log

     val mappings: Seq[(File, String)] = {
     val libs = unmanagedNativeLibraries.value.toSeq ++ managedNativeLibraries.value.toSeq
     libs.map{ case (platform, file) =>
     file -> NativeLoader.fullLibraryPath(
     (nativeLibraryPath in Compile).value,
     platform)
     }
     }

     val manifest = new java.util.jar.Manifest
     val namer = (artifactName in packageNative).value
     val jar: File = (target in nativeCompile).value / namer(
     scalaVersion,

     (artifactName in packageNative).value
     )

     Package.makeJar(mappings, jar, manifest, log)
     jar
     },
     */

    //Add native jar to runtime classpath. Note that it is not added as a resource (this would cause
    //the native library to included in the main jar).
    //unmanagedClasspath in Runtime += Attributed.blank(packageNative.value),

    //Fork new JVM when running locally, since native libraries can only be loaded once
    //fork in run := true

  /*
  override lazy val projectSettings =
    Defaults.packageTaskSettings(packageNative, packageNativeMappings) ++
  addArtifact(artifact in packageNative, packageNative) ++
  inConfig(Compile)(settings) ++ Seq(

    packageNativeMappings := {
      val libs = (unmanagedNativeLibraries in Compile).value.toSeq ++
        (managedNativeLibraries in Compile).value.toSeq
      libs.map{ case (platform, file) =>
        file -> NativeLoader.fullLibraryPath(
          (nativeLibraryPath in Compile).value,
          platform)
      }
    },

    artifactClassifier in packageNative := Some("native"),

    //this is file name of the artifact
    artifactName := { (sv: ScalaVersion, module: ModuleID, artifact: Artifact) =>
      artifact.name + "-foso" + module.revision + "." + artifact.extension
    },

    artifact in packageNative := {
      Artifact("foo", "jar", "jar", Some("native"), Nil, None, Map("platform" -> "all"))
    },

    crossVersion in packageNative := CrossVersion.Disabled
//    projectID in packageNative := { projectID.value.copy(crossVersion = CrossVersion.Disabled) }


  )
   */

}
